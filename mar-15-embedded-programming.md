# Embedded Programming {#embedded-programming}

#### Have you:

* [ ] Documented what you learned from reading a microcontroller datasheet.

* [ ] What questions do you have? What would you like to learn more about?

* [ ] Programmed your board

* [ ] Described the programming process/es you used

* [ ] Included your code


[![Embedded programming](https://img.youtube.com/vi/wdKsoC5_NIc/0.jpg)](https://www.youtube.com/watch?v=wdKsoC5_NIc "Embedded programming")

#### 2017 Class Review

[André Rocha](http://archive.fabacademy.org/archives/2017/fablabfct/students/329/week1a.html), FCTFabLab (Portugal), was trying to send a "bootloader" to his ISP. Neil interjected André was misusing the term "bootloader". Going to Neil's "helloEcho" example code, Neil demonstrated that it was just a program that was loaded by a programmer. A bootloader is something different, there are multiple bootloaders available. The processor is designed to be programmed through the ISP interface. It is not directly designed to be programmed from the serial interface. A bootloader is a program that takes a program through the serial interface. An ISP rewrites the whole memory on a processor, but a bootloader will sit on the processor and load programs over itself. In this way, the ISP is no longer needed to program the processor. It's two routes, either you use an ISP to program and rewrite the whole memory of the processor; or you use a bootloader program to load programs and communicate with the board directly.

[Birkir Thor](http://archive.fabacademy.org/archives/2017/fablabhornafjordur/students/201/week8.html), Fab Lab Hornafjordur (Iceland), had a final project to make a guitar. Neil searched for Alex Schaub's [documentation](http://academy.cba.mit.edu/classes/applications_implications/musical_instruments/index.html), and Emma Pareschi reminded him where it was linked. Jens Dyvik had Alex in his lab, they all discussed the final project and the developments on mtm projects at [Fellesverkstedet](https://www.fablabs.io/labs/fellesverkstedet). Returning to Birkir, Neil remarked that his documentation was exactly what should be uploaded to the repository. Birkir outlined the workflow for using the Arduino IDE and an ISP to send a sketch to a board. Arduino IDE was not originally able to program ATTiny. David Mellis demonstrated that it was straight forward to do. To go further with the assignment and demonstrate multiple methods, Neil suggested to burn a bootloader using the Arduino IDE and to try using C to load the program directly.

[Ilia Feldshtein](http://archive.fabacademy.org/archives/2017/fablabisrael/students/104/week8.html), Fab Lab Israel (Israel), at the first plugin, his board got heated. Neil explained that heat means power is going where it shopuldn't. If the board is getting hot. Then, it's "fried". Neil asked if Ilia left off the external pull up resistor on the example board. Ilia said that he left one off between the ATTiny and the button. Neil explained that you do not need a pull up resistor to the button. There is a pull up resistor in the ATTiny that can be turned on. Looking at the datasheet, Neil referred to the I/O port. The pin can be an input or an output. It has an onboard pull up resistor. Logically, you write a 0 or 1 to the pin. If you write a 1 to the pin, it turns on the pull up. Ilia experienced problems with USB identification. The example board, Neil explained, has an FTDI and ISP connection. On the ISP, there is a pin labeled V, this is an output to tell the programmer what voltage the board is operating at. The FTDI header has a VCC pin and it's a power supply. Commercial programmers expect the V pin on the ISP to be an output. If the board is connected through the ISP and not the FTDI. Then, it shouldn't work because the FTDI is the power supply. After trying with the designed board, Ilia tried with a Photon board to practice coding. He then tried coding with an Arduino commercial board. Referring back to Birkir's documentation, Neil reminded Ilia of the workflow that was discussed. While Ilia's back up to the assignment was good, the bill of materials for the example boards are $1's. Once mastered, the goal is to be able to pick a processor, pick the form factor, and pick the peripherals. 

[Javi Burongarcia](http://archive.fabacademy.org/archives/2017/fablabmadridceu/students/257/8-week-embedded-programming.html), Fab Lab Madrid CEU (Spain), had the programmer and the echoboard. He demonstrated both the Arduino IDE and directly with C code. Javi milled away the excess copper from the PCB, Javi is "an aesthetic person". For high frequency or low noise circuit boards, this is important to do. It's optional for this assignment. Javi was a little confused by the code. Neil walked through both the sketch and the C code. In the sketch for the example board, a function called _digitalWrite()_ sends arguments and "magically" writes to a pin. In the C code, Neil uses macros. Going back to the datasheet, Neil explains that each section ends with a description of registers. Direction register (DDR) says do you talk out or in. Port send data out. Pin listens in. In the C code, Neil moves a 1 on to Pin 5. Looking at the clock system, the clock system has its own register. The register says that the processor should click every time the clock ticks. Then, we are telling the register that the LED is an output. The point of the C code is to demonstrate that you only need one line of code to talks to pins or ports. In this way, you are not buffered by a library. Javi has a beautiful example of a baby walker and had a simplified final project "Fab Window" that can be applied in any house.

[APOORV VATS](http://archive.fabacademy.org/archives/2017/fablabakgec/students/462/week8_Embedded%20Programming/assignment8.html), AKGEC (India), tried assembly language to also program his board. Apoorv described this as using a third language to program the board. Neil explained that Arduino is not a separate language. Arduino is C but additionally call libraries. The IDE uses gcc. the point behind Neil's example is to demonstrate a way to directly call gcc and code without the overhead of Arduino. Despite the supposed misinterpretation of "language", Apoorv demonstrates the size comparison of the code. An Arduino sketch with included libraries is 952 bytes, a C program is 100 bytes, and Assembly program is only 44 bytes. This prompted Neil to correct himself in stating that C code was a "ground truth." You can go to a lower level than just plain C by programming in Assembly. With Assembly, there are no toolchains or libraries. Lower than Assembly is hex code which is even lighter, but not many people go to that level. Neil recommended the Arduino IDE to leverage the libraries written for it. He recommended C code for iteration, looping, and subreoutines. He recommended Assembly for considering every byte of code to every clock tick. Apoorv also experimented with interrupt based programming. His experience was sometime the reverse of the expected output. This led Neil to explain [Schmitt Triggers](http://www.ti.com/lit/an/scea046/scea046.pdf). Schmitt Triggers are useful when a user needs to convert a sine wave into a square wave. This is a technique that is applied in software.

#### 2017 Class Notes

An embedded processor, such as an ATTiny, is a complete computer system on a chip that costs 75 cents. An Arduino is actually five separate things that get mixed. It is a board. It is C libraries. It is a bootloader. It is also a header. Each of those five components gets mixed. The purpose of this week is to untangle them.

Computers historically are known as having a Harvard architecture. The Mark I computer is also famous for having the first computer bug. A von Neumann architecture stores the data and program are in the same place, in that way they can modify themselves. CISC instructions are on desktop computers. RISC are simpler and are used in a processors. Microprocessors are computer chips that need other chips to function. Microcontrollers condense multiple computer chip functions into one package.

In a $1 microcontroller, there are many things. One of the things is memory. These come as registers which the microcontroller operates on very quickly. There is RAM which stores data. SRAM is fast. DRAM is slower but with more capacity. EEPROM is nonvolatile memory. You can write into it, and it will save the value. FLASH is also nonvolatile. It's harder to write to but that is where you write programs. Fuse memory is where configurations are stored.

There are also many peripherals. There is an A/D (analog to digital) that converts a voltage into a number. A comparator compares two numbers quickly. D/A (digital to analog) turn data into a voltage. A timer measures time. a counter measures events. PWM (pulse width modulation) varies pulses that you would use to control motors, displays, etc. USART and USB are peripherals for communication to send messages in and out.

Processors are rated by the word size. The example microcontroller is 8-bit meaning the register stores 8 bits. Many desktop computers are 32 or 64-bit. The 8-bit microcontrollers work on "little" words. We are going to use these packages at 20 MHz. It will do one instruction per clock cycle. So, that means 20 million instruction per second. 64-bit math can be achieved. There is a threshold of quality for audio, but it can be done.

[![Atmel: Vegard Wollan and Alf-Egil Bogen Discuss AVR’s Inception](https://img.youtube.com/vi/VUyEFr0YHJs/0.jpg)](https://www.youtube.com/watch?v=VUyEFr0YHJs "Atmel: Vegard Wollan and Alf-Egil Bogen Discuss AVR’s Inception")

The AVR family was originally designed by Egil Bogen and Vegard Wollan. The idea was a modern compiler like gcc is designed to target high-performance RISC processors. 8051 or PIC family did not fit modern compiler design. AVR family are embedded processors that you can use modern compilers to program. They are an intersection of cheap parts and high performance.

--I stopped at 15:15, will pick up as soon as possible

#### Sources

Cockrill, C. _Understanding Schmitt Triggers_. Texas Instruments, Sept. 2011, www.ti.com/lit/an/scea046/scea046.pdf.